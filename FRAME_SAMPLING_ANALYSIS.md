# 프레임 샘플링 수에 따른 성능 분석
## 16프레임 vs 60프레임 비교

---

## 1. 메모리 사용량 비교

### 1.1 단일 프레임 크기
```
InternVL 입력 해상도: 448 × 448
채널: 3 (RGB)
데이터 타입: float32 (4 bytes)

단일 프레임 크기:
  448 × 448 × 3 × 4 bytes = 2,408,448 bytes ≈ 2.4 MB
```

### 1.2 배치 프레임 메모리 (모델 입력)

| 프레임 수 | 배치 크기 | 메모리 | 증가율 |
|----------|---------|--------|--------|
| 1프레임 | (1, 3, 448, 448) | 2.4 MB | - |
| **16프레임** | (16, 3, 448, 448) | **38.4 MB** | 기준 |
| 32프레임 | (32, 3, 448, 448) | 76.8 MB | 2.0배 |
| **60프레임** | (60, 3, 448, 448) | **144 MB** | **3.75배** |
| 128프레임 | (128, 3, 448, 448) | 307.2 MB | 8배 |

### 1.3 전체 파이프라인 메모리 사용 (비디오 1개 처리 시)

```
프레임 로딩:          60프레임 = 144 MB
모델 가중치:          8.5B 파라미터 ≈ 34 GB (bfloat16)
활성화 맵:            배치 크기에 따라 증가
임시 버퍼:            모델 내부 연산용

추정 총 메모리:
  - 16프레임: ~34 GB + 50-100 MB = ~34.05 GB
  - 60프레임: ~34 GB + 200-300 MB = ~34.2 GB

증가량: ~150-200 MB (모델 가중치에 비하면 미미함)
```

---

## 2. 계산 시간 비교

### 2.1 InternVL 추론 시간

InternVL3.5-8B의 추론 시간은 배치 크기에 **선형적으로** 증가합니다.

```python
# 벤치마크 (A100 GPU 기준)
프레임 수별 추론 시간:

1프레임:  ~50-100ms
16프레임: ~800ms - 1.2초  (1 프레임당 50-75ms)
32프레임: ~1.6-2.4초
60프레임: ~3.0-4.5초      (약 3.75배)
128프레임: ~6-8초

실제 측정값 (사용자 기준):
  38,000개 비디오 × 37시간 = 약 3.5초/비디오 (평균)
  이는 프레임 로딩 + 추론 + 저장을 포함한 전체 시간
```

### 2.2 전체 파이프라인 시간 (비디오 1개)

| 단계 | 16프레임 | 60프레임 | 증가율 |
|------|---------|---------|--------|
| 프레임 로딩 | 50-100ms | 200-300ms | 3배 |
| InternVL 추론 | 800ms-1.2s | 3-4.5s | 3.75배 |
| 후처리 (평균화 등) | 10-20ms | 10-20ms | 1배 |
| 파일 저장 | 5-10ms | 5-10ms | 1배 |
| **총 시간** | **~900ms-1.3s** | **~3.2-4.8s** | **3.5배** |

### 2.3 전체 대규모 처리 시간 예상

**현재 상황**: 38,000개 비디오 × 37시간

```
현재 (16프레임):
  1비디오 당 ~3.5초
  38,000 × 3.5초 = 133,000초 ≈ 37시간

60프레임으로 변경:
  1비디오 당 ~3.5초 × 3.5배 = ~12.25초
  38,000 × 12.25초 = 465,500초 ≈ 129시간

**약 3.5배 증가** → 37시간 → 129시간
```

---

## 3. 임베딩 파일 크기 비교

### 3.1 최종 임베딩 파일 크기

현재 설계: `mean(dim=(0,1))`로 모든 프레임을 평균화 → 단일 4096차원 벡터

```
파일 크기:
  - 16프레임: 4096 × 4 bytes = 16,384 bytes ≈ 16 KB
  - 60프레임: 4096 × 4 bytes = 16,384 bytes ≈ 16 KB

결론: 파일 크기는 **동일** (평균화되기 때문)
```

### 3.2 프레임별 임베딩을 모두 저장하는 경우

만약 모든 프레임의 임베딩을 개별 저장한다면:

```
프레임별 임베딩:
  - 16프레임: 16 × 4096 × 4 bytes = 262,144 bytes ≈ 256 KB
  - 60프레임: 60 × 4096 × 4 bytes = 983,040 bytes ≈ 960 KB

전체 저장소:
  - 38,000개 비디오 × 16프레임: 9.7 GB
  - 38,000개 비디오 × 60프레임: 36.5 GB (3.75배)
```

---

## 4. 클러스터링 영향

### 4.1 Leiden 클러스터링 성능

Leiden 알고리즘은 임베딩 수에 의존하지만, 임베딩 자체는 크기가 같음:

```
현재 상황:
  - 38,000개 임베딩 (각 4096차원)
  - 클러스터링 시간: ~수 초

60프레임으로 변경해도:
  - 여전히 38,000개 임베딩 (각 4096차원)
  - 클러스터링 시간: 동일

왜냐하면 최종 임베딩이 평균화되기 때문
```

### 4.2 임베딩 품질의 변화

- **16프레임**: 비디오 전체를 균등하게 샘플링
- **60프레임**: 더 많은 프레임 정보를 평균화

```
기대 효과:
  - 60프레임: 더 안정적인 임베딩 (노이즈 감소)
  - 60프레임: 미세한 변화를 놓칠 가능성 (평균화로 인해)

결론: 임베딩 **품질은 개선 가능성** 있음
      하지만 계산 비용이 3.5배 증가
```

---

## 5. 권장 최적 프레임 수

### 5.1 선택 기준

| 기준 | 선택 |
|------|------|
| **속도 우선** | 8프레임 (37시간 → ~18시간) |
| **현재 균형** | 16프레임 (기본) - 균형잡힌 선택 |
| **품질 우선** | 24프레임 (~1.5배) 또는 32프레임 (~2배) |
| **최고 품질** | 48프레임+ (시간 2배 이상 증가) |

### 5.2 성능 vs 품질 그래프

```
품질
  ↑
  │     ●(60프레임)
  │    ●(32프레임)
  │   ●(24프레임)
  │  ●(16프레임) ← 현재 (권장)
  │ ●(8프레임)
  │●(4프레임)
  └─────────────→ 계산시간 및 자원
    1배  2배  3배  4배

● 점은 가치의 감소 곡선을 따름
  - 4→8프레임: 큰 개선 (비용 0.5배)
  - 16→24프레임: 중간 개선 (비용 1.5배)
  - 32→60프레임: 작은 개선 (비용 3.75배)
```

---

## 6. 비교표: 전체 요약

| 항목 | 16프레임 | 60프레임 | 차이 |
|------|---------|---------|------|
| **메모리 (로딩)** | 38 MB | 144 MB | 3.75배 |
| **추론 시간** | 1초 | 3.5-4.5초 | 3.5-4.5배 |
| **전체 시간** | 37시간 | ~129시간 | 3.5배 |
| **파일 크기** | 16 KB | 16 KB | 동일 |
| **클러스터링** | 영향없음 | 영향없음 | 동일 |
| **임베딩 품질** | 좋음 | 더 좋음* | +5-10%* |

\* 예상치, 실제 측정 필요

---

## 7. 실험 제안

### 7.1 A/B 테스트 계획

```bash
# 1단계: 동일한 100개 비디오로 테스트
mkdir test_frames

# 2단계: 16프레임 처리
time python video_curation_pipeline.py \
    --frame-dir ./test_frames \
    --output-dir ./output_16 \
    --num-frames 16

# 3단계: 24프레임 처리 (config 수정 후)
time python video_curation_pipeline.py \
    --frame-dir ./test_frames \
    --output-dir ./output_24 \
    --num-frames 24

# 4단계: 32프레임 처리
time python video_curation_pipeline.py \
    --frame-dir ./test_frames \
    --output-dir ./output_32 \
    --num-frames 32

# 5단계: 60프레임 처리
time python video_curation_pipeline.py \
    --frame-dir ./test_frames \
    --output-dir ./output_60 \
    --num-frames 60
```

### 7.2 품질 비교

```python
# 각 설정으로 생성된 임베딩 비교
embeddings_16 = np.load('output_16/video_0.npy')
embeddings_24 = np.load('output_24/video_0.npy')
embeddings_32 = np.load('output_32/video_0.npy')
embeddings_60 = np.load('output_60/video_0.npy')

# 코사인 유사도 비교
from sklearn.metrics.pairwise import cosine_similarity

sim_16_24 = cosine_similarity([embeddings_16], [embeddings_24])[0, 0]
sim_16_32 = cosine_similarity([embeddings_16], [embeddings_32])[0, 0]
sim_16_60 = cosine_similarity([embeddings_16], [embeddings_60])[0, 0]

print(f"유사도 (16 vs 24): {sim_16_24:.4f}")
print(f"유사도 (16 vs 32): {sim_16_32:.4f}")
print(f"유사도 (16 vs 60): {sim_16_60:.4f}")

# 유사도가 낮으면 → 큰 차이가 있다는 의미
```

---

## 8. 권장사항

### 현재 상황에서:

| 목표 | 추천 프레임 수 | 예상 시간 |
|------|-------------|---------|
| 최대 속도 | 8프레임 | ~18시간 |
| **현재 균형** | **16프레임** | **37시간** |
| 약간 더 좋음 | 24프레임 | ~55시간 |
| 더 좋음 | 32프레임 | ~74시간 |

### 결론:
- **16프레임은 합리적인 선택**
- 60프레임은 **비용 대비 이득이 적음** (3.5배 시간 증가)
- **24-32프레임** 테스트를 권장 (1.5-2배 시간으로 임베딩 품질 개선)

---

## 9. CLI 옵션 추가 제안

현재 고정된 `num_frames=16`을 CLI에서 조정 가능하도록:

```python
# pipeline/cli.py에 추가

parser.add_argument(
    "--num-frames",
    type=int,
    default=16,
    choices=[4, 8, 16, 24, 32, 48, 64],
    help="Number of frames to sample from each video (default: 16)"
)

# 사용법
parser.add_argument(
    "--frame-sample-strategy",
    type=str,
    default="uniform",
    choices=["uniform", "random", "first", "last"],
    help="Frame sampling strategy (default: uniform)"
)
```

**사용 예시**:
```bash
# 현재 (16프레임, 균등)
python video_curation_pipeline.py --frame-dir ./trainlake

# 24프레임, 균등
python video_curation_pipeline.py --frame-dir ./trainlake --num-frames 24

# 32프레임, 무작위
python video_curation_pipeline.py --frame-dir ./trainlake --num-frames 32 --frame-sample-strategy random

# 8프레임 (빠른 처리)
python video_curation_pipeline.py --frame-dir ./trainlake --num-frames 8
```

